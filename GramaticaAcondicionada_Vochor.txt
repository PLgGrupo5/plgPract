//*************************************************************************************************************************************
//  REGLAS QUE CORRESPONDEN AL ANALIZADOR LEXICO
//*************************************************************************************************************************************
NOTA: Esta especificacion esta orientado al uso en ANTLR. Lo mas comun es definir el Analizador Lexico mediante un Automata Finito o Expresiones regulares.

NOTA: Las siguientes reglas hacen uso de expresiones regulares extendidas en sus partes derechas
    ('?', '*', '+') - Nivel prioridad maxima
    ('·') - Nivel prioridad intermedia
    ('|') - Nivel prioridad minima
        * Puede alterarse la prioridad mediante el uso de parentesis.

//Tipos (Palabras reservadas). Esto se puede implementar en el Analizador lexico a capon o podemos optar por declararlas como palabras reservadas, ya sea mediante una estructura auxiliar propia o mediante las propias opciones que nos ofrezca nuestro metacompilador. En el caso de ANTLR podemos definirlas directamente en la seccion "tokens"
// tipo_ent ->('i' | 'I')·('n' | 'N')·('t' | 'T')
// tipo_real -> ('r' | 'R')·('e' | 'E')·('a' | 'A')·('l' | 'L')
    NOTA: A pesar de que unicamente se trata de 2 palabras reservadas haremos uso del potencial de ANTLR y las incluiremos como palabras reservadas en la seccion "tokens". Aporta mayor flexibilidad y mantenibilidad al traductor.
        Para conseguir que el Analizador léxico no distinga entre mayúsculas y minusculas podemos hacer uso de la opcion
        Si desactivamos la opcion general de checkeo de tokens tendremos que hacer uso de la siguiente opcion local: options { testLiterals=true; } en la regla 'var'
    NOTA: Para solventar el problema de las mayúsculas y minusculas indistinguibles disponemos de la opcion global: caseSensitiveLiterals=false;

//Expresiones basicas: literal entero, literal real y variable
lit_ent -> '0' | '-'?·(digito ~ '0')·digito*
lit_real -> '0' | '-'?·(digito ~ '0')·digito*·'.'·digito*·(digito ~ '0')? // No se si es mas adecuado indicar el cero real como '0'·'.'·'0' (Como la cerveza, =D)
var -> ('_' | letra)·('_' | letra | digito)*

//Separador
separa -> ';'

//Fin del programa
fin -> '$'

//Comentarios de linea. NO DEFINEN TOKENS y por tanto iran declarados como protected en ANTLR
//coment -> '@'('_' | '@' | ' ' | '\t' | letra | digito)*·'\r'·'\n' //Habría que añadir todos los posibles caracteres que pretendemos que acepte el lenguaje.
coment -> '@'·(~('\r'·'\n'))*
    //OJO!: Los comentarios unicamente son reconocidos por el Analizador Lexico para ser eliminados. Al igual que los carateres ', '\t', etc
    //NOTA: Para que el Analizador lexico no lo identifique como un token debemos hacer uso de: { $setType(Token.SKIP); }

//Caracteres que eliminara el Analizador lexico. NO DEFINEN TOKENS y por tanto iran declarados como protected en ANTLR
blanco -> (' ' | '\t')
saltolinea -> '\r'·'\n'
    NOTA: Con la acción {newline();}  se establece que los "tokens" correspondientes (saltolinea) provocan un cambio de línea, por lo que los contadores de fila y columna son actualizados convenientemente.

//Reglas auxiliares para mejorar la legibilidad del resto de reglas. NO DEFINEN TOKENS
letra -> ['a'-'z'] | ['A'..'Z'] | 'ñ' | 'Ñ' | 'á' | 'Á' | 'é' | 'É' | 'í' | 'Í' | 'ó' | 'Ó' | 'ú' | 'Ú' | 'ü' | 'Ü' // Alfabeto español
digito -> ['0'-'9']

//Operadores
op_in -> "in"
op_out -> "out"
op_asig -> '='
op_menq -> '<'
op_mayq -> '>'
op_menoig -> "<="
op_mayoig -> ">="
op_ig -> "=="
op_dist -> "!="
op_sum -> '+'
op_res -> '-'
op_olog -> "||"
op_mult -> '*'
op_div -> '/'
op_mod -> '%'
op_ylog -> "&&"
op_cambsig -> '-'
op_neglog -> '!'
op_castent -> "(int)"
op_castreal -> "(real)"

//*************************************************************************************************************************************
//  REGLAS QUE CORRESPONDEN AL ANALIZADOR SINTACTICO
//*************************************************************************************************************************************
NOTA: Las siguientes reglas seran especificadas en notacion EBNF

***********************************
Recuerda solucion publicada en campus por Vochor. No asociatividad
    10. Desig -> Exp '=/=' Exp | Exp    - Con la regla 10 impido que la desigualdad pueda asociar sin el empleo obligatorio de paréntesis y permito que coexista con otros operadores sin hacer obligatorio el empleo de paréntesis.
***********************************

INI -> PROG fin

PROG -> DECs ACCs

DECs -> DEC DECs | lambda  //Uilizamos recursion a derechas y evitamos tener que modificarlo en la fase de acondicionamiento

DEC -> (tipo_ent | tipo_real) var separa

// FACT :: ACCs -> ACC ACCs | ACC
ACCs -> ACC FACCs
FACCs -> ACCs | lambda

ACC -> EXP0 separa

//Reglas asociadas a las expresiones ordenadas de manera que se verifican los criterios de prioridad
EXP0 -> OP0 EXP1 | EXP1     // EXP1 tiene que reducirse a variable

// FACT :: EXP1 -> EXP2 OP1 EXP1 | EXP2    // EXP2 tiene que reducirse a variable
EXP1 -> EXP2 FEXP1
FEXP1 -> OP1 EXP1 | lambda

// FACT :: EXP2 -> EXP3 OP2 EXP3 | EXP3
EXP2 -> EXP3 FEXP2
FEXP2 -> OP2 EXP3 | lambda

// REC-IZQ :: EXP3 -> EXP3 OP3 EXP4 | EXP4
EXP3 -> EXP4 REXP3
REXP3 -> OP3 EXP4 REXP3 | lambda

// REC-IZQ :: EXP4 -> EXP4 OP4 EXP5 | EXP5
EXP4 -> EXP5 REXP4
REXP4 -> OP4 EXP5 REXP4 | lambda

EXP5 -> OP5 EXP5 | EXP6

EXP6 -> OP6 EXPBAS

EXPBAS -> lit_ent | lit_real | var | ( EXP0 )

//Operadores de lectura y escritura (nivel 0, unarios, prefijos, no asociativos)
OP0 -> op_in | op_out

//Operador de asignacion (nivel 1, binario, infijo, asocia a derechas)
OP1 -> op_asig

//Operadores comparativos (nivel 2, binarios, infijos, no asociativos)
OP2 -> op_menq | op_mayq | op_menoig | op_mayoig | op_ig | op_dist

//Operadores aditivos (nivel 3, binarios, infijos, asocian a izquierdas)
OP3 -> op_sum | op_res | op_olog

//Operadores multiplicativos (nivel 4, binarios, infijos, asocian a izquierdas)
OP4 -> op_mult | op_div | op_mod | op_ylog

//Operadores unarios (nivel 5, unarios, prefijos, asociativos) //NOTA: Un operador unario solo pueda asociar en el sentido opuesto al sentido en el que se encuentro el operador situado, es decir, op prefijo => Asocia Der y op sufijo => Asocia Izq
OP5 -> op_cambsig | op_neglog

//Operadores de conversion de tipo (nivel 6, unarios, prefijos, no asociatvios)
OP6 -> op_castent | op_castreal
